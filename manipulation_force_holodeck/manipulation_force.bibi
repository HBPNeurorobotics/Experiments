<?xml version="1.0" encoding="UTF-8"?>
<bibi xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.humanbrainproject.eu/SP10/2014/BIBI" xsi:schemaLocation="http://schemas.humanbrainproject.eu/SP10/2014/BIBI ../bibi_configuration.xsd">
  <brainModel>
    <file>brain_model/somatosensory_force.py</file>
    <populations population="motor" xsi:type="Range" from="0" to="1"/>
    <populations population="index_proximal_contraction_motor" xsi:type="Range" from="1" to="2"/>
    <populations population="index_proximal_extension_motor" xsi:type="Range" from="2" to="3"/>
    <populations population="index_distal_contraction_motor" xsi:type="Range" from="3" to="4"/>
    <populations population="index_distal_extension_motor" xsi:type="Range" from="4" to="5"/>
    <populations population="monitor_neurons" xsi:type="Range" from="1" to="5"/>
  </brainModel>
  <bodyModel>arm_robot_force/arm_robot_force.sdf</bodyModel>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.NeuronMonitor(nrp.brain.monitor_neurons, nrp.spike_recorder)
    def distal_contraction_neuron_monitor(t):
        return True
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    import gazebo_msgs.srv
    from rospy import ServiceProxy, wait_for_service
    from rospy import Duration
    clientLogger.info('Waiting for ROS Service /gazebo/apply_joint_effort')
    wait_for_service('/gazebo/apply_joint_effort')
    clientLogger.info('Found ROS Service /gazebo/apply_joint_effort')
    service_proxy = ServiceProxy('/gazebo/apply_joint_effort', gazebo_msgs.srv.ApplyJointEffort, persistent=True)
    duration_val = Duration.from_sec(0.02)

    @nrp.MapVariable("proxy", initial_value=service_proxy)
    @nrp.MapVariable("duration", initial_value=duration_val)
    @nrp.MapVariable("max_joint_force", initial_value=2.0)
    @nrp.MapVariable("force_per_spike", initial_value=0.1)
    @nrp.MapSpikeSink("proximal_extension", nrp.brain.index_proximal_extension_motor, nrp.population_rate)
    @nrp.MapSpikeSink("proximal_contraction", nrp.brain.index_proximal_contraction_motor, nrp.population_rate)
    @nrp.MapSpikeSink("distal_extension", nrp.brain.index_distal_extension_motor, nrp.population_rate)
    @nrp.MapSpikeSink("distal_contraction", nrp.brain.index_distal_contraction_motor, nrp.population_rate)
    @nrp.Neuron2Robot()
    def motor_to_force_tf(t, proxy, duration,  max_joint_force, force_per_spike, proximal_extension, proximal_contraction, distal_extension, distal_contraction):
        try:
            # A place holder for a finger muscle model
            def finger_muscle_model(spike_rate, force_per_spike):
                # In this simple model every motor neuron applies a fixed amount of torque to an associated joint
                # The current joint state and muscle contraction dynamics are ignored for simplicity
                f = min(max_joint_force.value, spike_rate * force_per_spike)
                return f

            # Apply f_per_spike torque for d nanoseconds for each spike from a motor neuron
            d = duration.value
            f_per_spike = force_per_spike.value

            # Proximal Index Finger
            f_proximal_ext = -finger_muscle_model(proximal_extension.rate, f_per_spike)
            f_proximal_cont = finger_muscle_model(proximal_contraction.rate, f_per_spike)

            # Apply force to antagonist muscle
            proxy.value.call('hollie_real_left_hand_Index_Finger_Proximal', f_proximal_ext,  None, d)
            # Apply force to synergist muscle
            proxy.value.call('hollie_real_left_hand_Index_Finger_Proximal', f_proximal_cont,  None, d)

            # Distal Index Finger
            f_distal_ext = -finger_muscle_model(distal_extension.rate, f_per_spike)
            f_distal_cont = finger_muscle_model(distal_contraction.rate, f_per_spike)
            # Apply force to antagonist muscle
            proxy.value.call('hollie_real_left_hand_Index_Finger_Distal', f_distal_ext, None, d)
            # Apply force to synergist muscle
            proxy.value.call('hollie_real_left_hand_Index_Finger_Distal', f_distal_cont, None, d)

        except Exception as e:
            clientLogger.info(str(e))

    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.MapVariable("topic_index", initial_value=-1)
    @nrp.MapVariable("spike_rate_scale", initial_value=125.0)
    @nrp.MapSpikeSource("extension", nrp.brain.index_distal_extension_motor, nrp.fixed_frequency)
    @nrp.MapSpikeSource("contraction", nrp.brain.index_distal_contraction_motor, nrp.fixed_frequency)
    @nrp.MapRobotSubscriber("target_angle", Topic('/target_angle_index_finger_distal', std_msgs.msg.Float64))
    @nrp.MapRobotSubscriber("topic_joint_state", Topic('/joint_states', sensor_msgs.msg.JointState))
    @nrp.Robot2Neuron()
    def distal_angle_to_motor(t, topic_index, spike_rate_scale, extension, contraction, target_angle, topic_joint_state):
        try:
            # Fetch current angle value from Gazebo
            if not topic_joint_state.value is None and not target_angle.value is None:
                # Safe repeated linear list search
                if topic_index.value == -1:
                    topic_index.value = topic_joint_state.value.name.index('hollie_real_left_hand_Index_Finger_Distal')
                current_angle = topic_joint_state.value.position[topic_index.value]
                # Encode motor neuron activation dynamics
                extension.rate = max(current_angle-target_angle.value.data, 0) * spike_rate_scale.value
                contraction.rate = max(target_angle.value.data-current_angle, 0) * spike_rate_scale.value
        except Exception as e:
            clientLogger.info(str(e))
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.MapVariable("topic_index", initial_value=-1)
    @nrp.MapVariable("spike_rate_scale", initial_value=25.0)
    @nrp.MapSpikeSource("extension", nrp.brain.index_proximal_extension_motor, nrp.fixed_frequency)
    @nrp.MapSpikeSource("contraction", nrp.brain.index_proximal_contraction_motor, nrp.fixed_frequency)
    @nrp.MapRobotSubscriber("target_angle", Topic('/target_angle_index_finger_proximal', std_msgs.msg.Float64))
    @nrp.MapRobotSubscriber("topic_joint_state", Topic('/joint_states', sensor_msgs.msg.JointState))
    @nrp.Robot2Neuron()
    def proximal_angle_to_motor(t, topic_index, spike_rate_scale, extension, contraction, target_angle, topic_joint_state):
        try:
            # Fetch current angle value from Gazebo
            if not topic_joint_state.value is None and not target_angle.value is None:
                if topic_index.value == -1:
                    topic_index.value = topic_joint_state.value.name.index('hollie_real_left_hand_Index_Finger_Proximal')
                current_angle = topic_joint_state.value.position[topic_index.value]
                # Encode motor neuron activation dynamics
                extension.rate = max(current_angle-target_angle.value.data, 0) * spike_rate_scale.value
                contraction.rate = max(target_angle.value.data-current_angle, 0) * spike_rate_scale.value
        except Exception as e:
            clientLogger.info(str(e))
    #]]>
  </transferFunction>

</bibi>
