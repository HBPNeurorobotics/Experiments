<?xml version="1.0" encoding="UTF-8"?>
<bibi xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.humanbrainproject.eu/SP10/2014/BIBI" xsi:schemaLocation="http://schemas.humanbrainproject.eu/SP10/2014/BIBI ../bibi_configuration.xsd">
  <brainModel>
    <file>brain_model/retina_tracking_rg_icub_brain.py</file>
    <populations population="ganglion_input_OFF" xsi:type="Range" from="0" to="320"/>
    <populations population="ganglion_input_ON" xsi:type="Range" from="320" to="640"/>
    <populations population="ganglion_output_OFF" xsi:type="Range" from="640" to="960"/>
    <populations population="ganglion_output_ON" xsi:type="Range" from="960" to="1280"/>
    <populations population="record" xsi:type="Range" from="960" to="1280"/>
  </brainModel>
  <bodyModel>icub_model/model_retina.sdf</bodyModel>
  <configuration src="green_tracking_retina.py" type="retina"/>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.NeuronMonitor(nrp.brain.record, nrp.spike_recorder)
    def all_neurons_monitor(t):
        return True
    #]]>
  </transferFunction>

  <!-- This transfer function is for saving all the neuron spikes on a file only -->
  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    from std_msgs.msg import Empty

    @nrp.MapVariable("brain_data", initial_value=None)
    @nrp.MapSpikeSink("all_neurons", nrp.brain.circuit[slice(0, 1280, 1)], nrp.spike_recorder)
    @nrp.Neuron2Robot(Topic('/dummy', Empty))
    def all_neurons_spike_monitor(t, brain_data, all_neurons):
        ns = brain_data.value
        if ns is None:
            ns = [0]*1280
        for q in all_neurons.times.tolist():
            ns[int(q[0])-nrp.config.brain_root.circuit[0]] = q[1]
        nss = map(str, ns)
        brain_data.value = ns
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    from sensor_msgs.msg import JointState
    from std_msgs.msg import Float64

    @nrp.MapVariable("eye_position", initial_value=0, scope=nrp.GLOBAL)
    @nrp.MapVariable("eye_velocity", initial_value=0, scope=nrp.GLOBAL)
    @nrp.MapRobotSubscriber("joints", Topic("/robot/joints", JointState))
    @nrp.MapRobotSubscriber("eye_vel", Topic("/robot/eye_version/vel", Float64))
    @nrp.Robot2Neuron()
    def set_eyepos(t, eye_position, eye_velocity, joints, eye_vel):
        joints = joints.value
        eye_position.value = joints.position[joints.name.index('eye_version')]
        if eye_vel.value is not None:
            eye_velocity.value = eye_vel.value.data
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    from gazebo_msgs.srv import SetModelState
    import rospy
    rospy.wait_for_service("/gazebo/set_model_state")
    service_proxy = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState, persistent=True)

    @nrp.MapVariable("target_freq", initial_value=0.3)
    @nrp.MapVariable("target_ampl", initial_value=0.3)
    @nrp.MapVariable("target_center", initial_value={'x': 0, 'y': 2.42, 'z': 1.2})
    @nrp.MapVariable("set_model_state_srv", initial_value=service_proxy)
    @nrp.Robot2Neuron() # dummy R2N
    def move_target(t, target_freq, target_ampl, target_center, set_model_state_srv):
        ms_msg =  gazebo_msgs.msg.ModelState()
        frequency = target_freq.value
        amplitude = target_ampl.value
        center = target_center.value
        ms_msg.model_name = 'Target'
        # set orientation RYP axes
        ms_msg.pose.orientation.x = 0
        ms_msg.pose.orientation.y = 1
        ms_msg.pose.orientation.z = 1
        # reference frame
        ms_msg.reference_frame = 'world'
        #pose
        ms_msg.pose.position.x = \
            center['x'] + np.sin(t * frequency * 2 * np.pi) * (float(amplitude) / 2)
        ms_msg.pose.position.y = center['y']
        ms_msg.pose.position.z = center['z']
        #scale
        ms_msg.scale.x = ms_msg.scale.y = ms_msg.scale.z = 1.0
        #call service
        response = set_model_state_srv.value(ms_msg)
        #check response
        if not response.success:
            clientLogger.info(response.status_message)
    #]]>
  </transferFunction>

 <transferFunction xsi:type="PythonTransferFunction">
  #<![CDATA[
  from std_msgs.msg import Float64

  @nrp.MapVariable("eye_velocity", scope=nrp.GLOBAL)
  @nrp.MapVariable("eye_position", scope=nrp.GLOBAL)
  @nrp.MapVariable("lastballpos", initial_value=-1)
  @nrp.MapSpikeSink("ganglion", nrp.brain.circuit[slice(0, 1280, 1)], nrp.spike_recorder)
  @nrp.MapVariable("trajectory", initial_value="sinusoidal", scope=nrp.GLOBAL)
  @nrp.Neuron2Robot(Topic('/robot/eye_version/pos', Float64))
  def move_eye(t, eye_velocity, eye_position, lastballpos, ganglion, trajectory):
      deg2rad = lambda deg: (float(deg) / 360.) * (2. * np.pi)
      tf = hbp_nrp_cle.tf_framework.tf_lib

      spike_counts_OFF = [0]*320
      spike_counts_ON = [0]*320
      for ev in ganglion.times:
          if ev[0] > 640 and ev[0] <= 960:
              spike_counts_OFF[int(ev[0]-641)] = spike_counts_OFF[int(ev[0]-641)] + 1
          elif ev[0] > 960 and ev[0] <= 1280:
              spike_counts_ON[int(ev[0]-961)] = spike_counts_ON[int(ev[0]-961)] + 1

      highest_spiking_count_OFF = max(spike_counts_OFF)
      highest_spiking_count_ON = max(spike_counts_ON)

      most_spiking_neuron_OFF = spike_counts_OFF.index(highest_spiking_count_OFF)
      most_spiking_neuron_ON = spike_counts_ON.index(highest_spiking_count_ON)

      # This is the current ball position estimation
      ball_pos = (most_spiking_neuron_ON + most_spiking_neuron_OFF) / 2.

      # Waiting some time for the robot to stabilize
      if t < 2:
          return eye_position.value

      if highest_spiking_count_OFF == 0 or highest_spiking_count_ON == 0:
          return eye_position.value

      if abs(ball_pos - lastballpos.value) > 20 and lastballpos.value != -1.:
          return eye_position.value

      ret = tf.cam.pixel2angle(ball_pos, 0)[0]

      lastballpos.value = ball_pos

      k = 0.2
      return eye_position.value + k*deg2rad(ret)
  #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.MapVariable("target_freq",scope=nrp.GLOBAL)
    @nrp.MapVariable("target_ampl", scope=nrp.GLOBAL)
    @nrp.MapVariable("target_delta", scope=nrp.GLOBAL)
    @nrp.MapVariable("trajectory", scope=nrp.GLOBAL)
    @nrp.Robot2Neuron()
    def compute_target_position_sine(t, target_freq, target_ampl, target_delta, trajectory):
        if trajectory != "sinusoidal":
            return

        frequency = target_freq.value
        amplitude = target_ampl.value
        target_delta.value = np.sin(t * frequency * 2 * np.pi) * (float(amplitude) / 2)
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.MapVariable("target_delta", scope=nrp.GLOBAL)
    @nrp.MapVariable("trajectory", scope=nrp.GLOBAL)
    @nrp.Robot2Neuron()
    def compute_target_position_linear(t, target_delta, trajectory):
        if trajectory != "linear":
            return

        if t <= 2 or t >= 5:
            return
        target_delta.value = 0.2*(t-2)
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.MapVariable("target_freq",scope=nrp.GLOBAL)
    @nrp.MapVariable("target_ampl", scope=nrp.GLOBAL)
    @nrp.MapVariable("target_delta", scope=nrp.GLOBAL)
    @nrp.MapVariable("trajectory", scope=nrp.GLOBAL)
    @nrp.Robot2Neuron()
    def compute_target_position_triang(t, target_freq, target_ampl, target_delta, trajectory):
        if trajectory != "triangular":
            return

        frequency = target_freq.value
        amplitude = target_ampl.value

        T = 1./frequency
        if t % T <= T/4.:
            target_delta.value = ((t % (T / 4.)) / (T / 4.)) * (float(amplitude) / 2.)
        elif t % T > T/4. and t % T <= 3*T/4.:
            target_delta.value = (float(amplitude) / 2.) - (((t - T/4.) % (T / 2.)) / (T / 2.)) * (float(amplitude))
        else:
            target_delta.value = ((t % (T / 4.)) / (T / 4.)) * (float(amplitude) / 2.) - (float(amplitude) / 2.)
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    @nrp.MapVariable("target_delta", scope=nrp.GLOBAL)
    @nrp.MapVariable("direction", initial_value=1)
    @nrp.MapVariable("counter", initial_value=0)
    @nrp.MapVariable("trajectory", scope=nrp.GLOBAL)
    @nrp.Robot2Neuron()
    def compute_target_position(t, target_delta, direction, counter, trajectory):
        if trajectory != "random_linear":
            return

        import random
        tf = hbp_nrp_cle.tf_framework.tf_lib
        counter.value = counter.value+ 1
        if counter.value == 50:
            counter.value = 0
            r = random.random()
            if r > 0.5:
                direction.value = -1 * direction.value
        if target_delta.value <= -.3 and direction.value == -1:
            direction.value = 1
        if target_delta.value >= .3 and direction.value == 1:
            direction.value = -1
        target_delta.value = target_delta.value + direction.value * 0.005
    #]]>
  </transferFunction>

  <transferFunction xsi:type="PythonTransferFunction">
    #<![CDATA[
    import std_msgs.msg
    from rospy.numpy_msg import numpy_msg
    @nrp.MapRobotSubscriber("ganglion_ON_data",Topic('/icub_model/left_eye_camera/retina/SNL_ganglion_ON/data', numpy_msg(std_msgs.msg.Float64MultiArray)))
    @nrp.MapRobotSubscriber("ganglion_OFF_data",Topic('/icub_model/left_eye_camera/retina/SNL_ganglion_OFF/data', numpy_msg(std_msgs.msg.Float64MultiArray)))
    @nrp.MapSpikeSource("ganglion_OFF", nrp.map_neurons(range(0, 320), lambda i: nrp.brain.ganglion_input_OFF[i]), nrp.dc_source)
    @nrp.MapSpikeSource("ganglion_ON", nrp.map_neurons(range(0, 320), lambda i: nrp.brain.ganglion_input_ON[i]), nrp.dc_source)
    @nrp.Robot2Neuron()
    def grab_image(t, ganglion_OFF, ganglion_ON, ganglion_ON_data, ganglion_OFF_data):

        getValue = hbp_nrp_cle.tf_framework.tf_lib.getValueFromFloat64MultiArray

        msg_ON = ganglion_ON_data.value
        msg_OFF = ganglion_OFF_data.value
        if msg_ON is not None and msg_OFF is not None :
            # magic_row = 100
            magic_row = 73
            for column in xrange(320):
                ganglion_OFF[column].amplitude = getValue(msg_OFF, magic_row, column)
                ganglion_ON[column].amplitude = getValue(msg_ON, magic_row, column)
    #]]>
  </transferFunction>

<transferFunction xsi:type="PythonTransferFunction">
  #<![CDATA[
  from sensor_msgs.msg import JointState

  @nrp.MapRobotSubscriber("joints", Topic("/robot/joints", JointState))
  @nrp.Neuron2Robot(Topic('/joint_states', JointState))
  def filter_joints_for_nice_output_on_frontend(t, joints):

      from sensor_msgs.msg import JointState

      joints = joints.value
      to_forward = ['eye_version']

      ret = JointState()
      ret.header = joints.header
      ret.name = to_forward
      ret.position = [joints.position[joints.name.index(x)] for x in to_forward]
      ret.velocity = [joints.velocity[joints.name.index(x)] for x in to_forward]
      ret.effort = [joints.effort[joints.name.index(x)] for x in to_forward]

      return ret
  #]]>
</transferFunction>

</bibi>
