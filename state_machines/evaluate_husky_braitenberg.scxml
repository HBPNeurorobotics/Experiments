<?xml version="1.0" encoding="utf-8"?>
<!-- Evaluating State Machine -->
<sc:scxml xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:sc="http://schemas.humanbrainproject.eu/SP10/2015/ExDConfig/scxml"
          xmlns:ros="http://schemas.humanbrainproject.eu/SP10/2015/ExDConfig/SCXMLExt/ROS"
          xsi:schemaLocation=
                  "http://schemas.humanbrainproject.eu/SP10/2015/ExDConfig/scxml hbp-scxml/hbp-scxml.xsd
                    http://schemas.humanbrainproject.eu/SP10/2015/ExDConfig/SCXMLExt/ROS hbp-scxml/scxml-ros-extensions.xsd"
          version="1.0" datamodel="python-smach" initial="waitForScreenSwitch">
    <!-- We can manually define a condition function that evaluates for a given point whether it is in the cuboid
        determined by the two points boxP1 and boxP2 -->
    <sc:script>
        <![CDATA[
        def pointInBox(point, boxP1, boxP2):
            return (min(boxP1.x, boxP2.x) < point.x < max(boxP1.x, boxP2.x) and
                   (min(boxP1.y, boxP2.y) < point.y < max(boxP1.y, boxP2.y) and
                   (min(boxP1.z, boxP2.z) < point.z < max(boxP1.z, boxP2.z)
        ]]>
    </sc:script>

    <!-- We manually define the region in front of the two screens that are the target area for the robot to enter -->
    <!-- left_* and right_* should be replaced by the actual values. It is further possible to derive the values
        by first querying Gazebo for the screen position and then adding some margins. -->
    <sc:datamodel>
        <sc:data id="left_screen_P1"
                 expr="geometry_msgs.msg.Point(left_x1, left_y1, left_z1)"/>
        <sc:data id="left_screen_P2"
                 expr="geometry_msgs.msg.Point(left_x2, left_y2, left_z2)"/>

        <sc:data id="right_screen_P1"
                 expr="geometry_msgs.msg.Point(right_x1, right_y1, right_z1)"/>
        <sc:data id="right_screen_P2"
                 expr="geometry_msgs.msg.Point(right_x2, right_y2, right_z2)"/>

        <sc:data id="max_waiting_duration" expr="Duration(secs=5)"/>
    </sc:datamodel>

    <!-- The current robot position as well as the simulation time are monitored ROS topics -->
    <sc:registerEvent xsi:type="ros:MessageOnROSTopic" topic="/gazebo/model_states" event="gazebo.model_states"
                      data_class="geometry_msgs/Pose"/>
    <sc:registerEvent xsi:type="ros:MessageOnROSTopic" topic="clock" event="timer"
                      data_class="std_msgs/Time"/>

    <!-- While there was no change of the screen color this state machine is idle -->
    <sc:state id="waitForScreenSwitch">
        <sc:transition event="experiment_control.screen_switched_color"
                       target="waitForRobotToArrive">
            <sc:if cond="_event.screen_id == 'left_vr_screen'">
                <sc:assign location="match_P1" expr="left_screen_P1"/>
                <sc:assign location="match_P2" expr="left_screen_P2"/>
                <sc:elseif cond="_event.screen_id == 'right_vr_screen'"/>
                <sc:assign location="match_P1" expr="right_screen_P1"/>
                <sc:assign location="match_P2" expr="right_screen_P2"/>
            </sc:if>
        </sc:transition>
    </sc:state>

    <sc:state id="waitForRobotToArrive">
        <sc:onentry>
            <!-- store simulation time when entering the state -->
            <sc:assign location="time_wait_started" expr="_x.currentSimulationTime"/>
            <sc:assign location="time_wait_limit" expr="time_wait_started + max_waiting_duration"/>
        </sc:onentry>

        <!-- if the robot reaches the target area in front of the screen the experiment was successfull -->
        <sc:transition event="robot.movement" cond="pointInBox(_event.data, match_P1, match_P2)"
                       target="success"/>
        <!-- if the robot takes longer than our predefined limit the experiment was not successfull -->
        <sc:transition event="timer" cond="_event.data.clock &gt; time_wait_limit"
                       target="failure"/>
    </sc:state>

    <sc:final id="success" outcome="FINISHED"/>
    <sc:final id="failure" outcome="FAILURE"/>
</sc:scxml>